!!Before we start

Clap is the new library for implementing ''command line applications'' in Pharo.
In this book, all examples assume that Pharo runs under a unix-like operating system (macOS or Linux).

!!!Command line applications

A command line application consists of a single command or of several related commands designed to be used either interactively from a shell, or programmatically in shell scripts.
Clap supports applications with rich command line syntax, supporting positional parameters, flags or options, and even nested subcommands like ==git==; it also tries to follow well-established conventions like short and long alternative syntaxes for flags.

The example below show two different uses of the standard ==seq== command, which generates numeric sequences:
[[[language=shell
> seq 3
1
2
3
> seq -s : 5 12
5:6:7:8:9:10:11:12
]]]

@@note In this book, code blocks show either the recording of a shell session, as above, or pieces of Pharo code, which you will recognize from the syntax. In shell sessions, lines starting with ==>== represent the command prompt followed by a command entered at that point; subsequent lines, up to the next prompt, show the output of that command.

!!!Pharo from the command line

To follow along the examples in this book, you will need to make Pharo available from the command line.
The easiest way is to install a standalone Pharo as described at *https://www.pharo.org/download#standalone*, instead of using Pharo Launcher.

The following instructions install a suitable virtual machine.
This assumes that the directory ==~/bin== is already in your ==$PATH==; feel free to pick someplace else but make sure to adapt your shell configuration accordingly.
[[[language=shell
> cd ~/bin
> curl https://get.pharo.org/64/vm80 | bash
]]]

The virtual machine comes with two executable wrapper scripts.
To open an image with its graphical user interface active, run it with ==pharo-ui==:
[[[language=shell
> pharo-ui Pharo8.image
]]]

Conversely, ==pharo== runs the image ''headless'', which is what we will use with Clap; note that in the absence of arguments, the image immediately quits with a help message:
[[[language=shell
> pharo Pharo8.image
]]]

To run Clap commands, follow the image name with the ==clap== keyword, then the command itself.
Clap comes with the traditional ''"hello world"'' as an example, if you want to try it:
[[[language=shell
> pharo Pharo8.image clap hello
hello, world.
> pharo Pharo8.image clap hello "pharo and clap"
hello, pharo and clap.
]]]

!!!Shell tricks for convenience

You will certainly find that repeating the virtual machine and image names before each and every command is a little tedious.
To make this more convenient, we advise that you define the following shell alias, which makes ==clap== look more like an actual shell command:
[[[language=shell
> alias clap='pharo Pharo8.image clap'
> clap hello
hello, world.
]]]

We could also define a direct shell alias to the ==hello== command:
[[[language=shell
> alias hello='pharo Pharo8.image clap hello'
> hello
hello, world.
]]]

However, while aliases make fine shortcuts, they are usually limited to interactive use, as a personal convenience feature.
To deploy a Clap command in the system's ==$PATH==, a wrapper shell script is good solution;
make such a script executable, place it under your ==$PATH==, ''et voilà !''
You now have a shell program implemented in Pharo!
[[[language=bash
#!/bin/bash
exec pharo Pharo8.image clap "$@"
]]]

Alternatively, functions provide a more scoped abstraction:
[[[language=bash
#!/bin/bash
function clap() { pharo Pharo8.image clap "$@"; }
function hello() { clap hello "$@"; }
# and later, in the script's body...
hello
]]]

Note the use of =="$@"== to pass all function arguments unchanged to the callee.
Please consult your shell's documentation for further advice on best practices.

@@note From this point on in the book, we will use the ==clap== shortcut defined above. Either alias or script are fine, since both provide the same syntax, so pick the one most convenient to you.

!!!Deploying Clap commands

A single Pharo image can host several Clap commands; in fact the base image includes commands for automating development tasks like loading code, running tests.
Loading additional commands into an image is as simple as loading the corresponding packages; Clap discovers declared commands automatically.

However, when installing a command on your own system, or packaging it for other users to install, you will have to consider a few details:
- Commands can modify their host image, but this does not make sense in the case of globally installed an application.
- Two commands installed in a common image cannot have the same name.
- The wrapper script for a command must know which image to run and with which VM.
We do not have generic answers to those questions but we are interested in your feedback.


!!Clap by Example

Through simple examples, this chapter shows how to declare the syntax and define the behavior of Clap commands.

!!!Trying a command from the workspace

The first step in defining a command line application with Clap is to describe its interface.
This is done by composing ''specification'' objects; for instance, the ==cmd== instance below describes a command with no parameters and simple behavior.
[[[
cmd := (ClapCommand withName: 'hello')
  meaning: [ :args |
    args context stdout << 'hello, clap'; lf ].
]]]



For development convenience, arbitrary command objects can be run from the Pharo workspace, by sending them the ==#activateWith:== message, passing the array of words that would be typed to invoke it:
[[[
cmd activateWith: #('hello').
]]]


Keep in mind that Clap commands are intended to be launched from a terminal.
This is why we have to pass that array of **strings**, since that's how all shell programs receive their arguments, but also why you will not see any output inside Pharo: the text gets printed on the standard output ''of the Pharo virtual machine process''.

@@note ''Launch Pharo from the terminal''. Most examples assume an interactive session, but print to the standard output. Launching Pharo from desktop environment means you would run examples blind.

@@note When testing from the image a command using ==#activateWith:== make sure that you only pass strings to the array.

!!!Registering a command for use in the terminal

Because a single Pharo image can host multiple independent Clap commands, Clap relies on a registration mechanism to automatically identify the set of commands available.

To register a command, simply return its specification from a factory method with the ==<commandline>== pragma.
By ''factory method'', we only mean a class-side method, with no argument, and which returns a command specification instance.
Clap does not assume anything else: how you name the method and in which class and package you define it is entirely up to you.

Let's first create a class to host our ==hello== command:
[[[
Object subclass: #ClapBookletHelloExample
  slots: {}
  classVariables: {  }
  package: 'Clap-BookletExamples'
]]]

And then we add a class-side method with the command definition.
Any meaningful unary selector is fine, but do not forget the ==<commandline>== pragma or to return the freshly built ==ClapCommand== instance:
[[[
ClapBookletHelloExample class >> helloClap
  <commandline>
  ^ (ClapCommand withName: 'hello')
    meaning: [ :args |
      args context stdout << 'hello, clap'; lf ]
]]]

Testing from the workspace is now a bit more concise:
[[[
ClapBookletHelloExample helloClap activateWith: #('hello')
]]]

However, you should now be able to run it from the command line as well.
Save your image, and, in a new terminal window, try the following; of course, use your specific virtual machine and image in place of ==pharo clap.image==:
[[[language=shell
> pharo clap.image clap hello
hello, clap
]]]

In command line examples, lines starting with ==>== indicate commands typed at the shell's prompt. Other lines represent the output of those commands.

@@note Pay attention, the case of the command name is important. ==(ClapCommand withName: 'hello')== is different from ==(ClapCommand withName: 'Hello')==.

@@note When developing a command, close the pharo image in which you are coding a command before testing it from the command-line. Else the system may not recognise immediately your new command and report unnecessary errors.

One last detail… You might wonder what the ==clap== word following the Pharo image name in the above definition is for.
At the time of this writing (Pharo 8), this keyword is necessary for Clap to exist alongside the legacy command line handlers.
Eventually, legacy command line handlers should be removed, making the ==clap== keyword superfluous, at which point it will certainly become optional, but in any case, it will be hidden behind the convenience shell aliases or functions that we're going to discuss next.

!!!Specifying parameters

Let's add some features to our basic command: for instance, greet an arbitrary recipient, in Esperanto, and shouting in uppercase letters:
[[[language=shell
> clap hello -s --language EN Pharo
SALUTON, PHARO!
]]]

Clap tries to follow common conventions, but also to keep a simple and coherent model.
- ''Positionals'' are for passing values from an open set, for instance ==Pharo== specifies the greeting recipient; as their name implies, they are recognized from their position, but their form conveys meaning. Because of that positionals must often be parsed into some adequate domain value, like a number or an URL.
- ''Flags'' are recognized from their form, usually beginning with dashes, in either short form like ==-s==, or long form like ==-\-shout==; a fixed set of them is acceptable, so they convey meaning through their presence, absence, number of occurrences, and order in the command line. A flag can have child positionals of its own, resulting in a named parameter, as in ==-\-language EN==. Here ==EN== is attached to the ==--language== named parameter.
- ''Commands'' are identified by a name hello in our example. They can have positionals and flags as children parameters, but also other commands, enabling applications with rich command line syntax like ==git==.


All parameters have a unique and mandatory ''canonical name'', which is the one expected when looking matches up.
Aliases or convenience names supplement the canonical name; for convenience, Clap derives the short and long form of flags from their canonical name, if needed.

@@note from SD to CDLM: what do you mean supplement. then we should put a ref how to define alias.
@@note from SD to CDLM: it would be good to see the definition of clap hello -s --language eo Pharo because it is really not clear. I have no idea what is eo

A ''description string'' will appear in documentation and help messages generated by Clap.
The ''meaning'' of a parameter defines the domain value or behavior of its matches.
Finally, compound parameters are ''composed'' from simpler ones using the ==#add:== message.


!!!Positional parameters

Positionals are the simplest form of parameters; each matches a word from the command line, and successive positionals match in order.

Because it is the position of the matched words that matters, instead of their form, positionals accept an open-ended set of values: numbers, URLs, file paths, application-specific identifiers, arbitrary strings…
However, since order is important, the user has to know which information comes first and which next, and of course they have to pay attention to the word-splitting rules of their shell and use quotes appropriately.

Let's extend the ==hello== command with a positional which specifies the recipient of the greeting.
To do this we make an instance of ==ClapPositional==, naming it ==who==, then we add it as a child to the command, and finally we extend the command's meaning block to use the new argument.
Note that a positional may be not given in such case we specify a default value using the message ==#implicitMeaning:==.

[[[
ClapBookletHelloExample class >> helloClap
  <commandline>
  ^ (ClapCommand withName: 'hello')
    add: ((ClapPositional withName: 'who')
      implicitMeaning: [ 'world' ]);
    meaning: [ :args |
      args context stdout
        << 'hello, ' ;
        << (args atName: 'who') value ;
        lf ]
]]]


We now have a parameterized greeting:

[[[language=shell
> clap hello Pharo
hello, Pharo
]]]

[[[language=shell
> clap hello
hello, world
]]]

!!!! What did we learn

The message ==#implicitMeaning:== provides the default value of the positionable when it is not given.
The messages ==#implicitMeaning:== as well as ==#meaning:== both expect a block as argument.
Also notice how the positionable argument is accessed from the method ==#meaning:== message via the message ==#atName:==.


!!! Playing more with positionals

Let us have fun with positional. Imagine that we want to have a simple command enumerating
consecutive period of the year as months.

[[[
> clap months 2 5
Counting, 2 3 4 5
]]]


[[[
> clap months
Counting, 1 2 3 4 5 6 7 8 9 10 11 12
]]]

We can define the command as follows:

[[[
myCounter
  <commandline>
  ^ (ClapCommand withName: 'months')
    	add: ((ClapPositional withName: 'from') implicitMeaning: [ 1 ]);
	 	add: ((ClapPositional withName: 'to') implicitMeaning: [ 12 ]);
    meaning: [ :args |
		| start end |
		start := (args atName: 'from') value asNumber.
		end := (args atName: 'to') value asNumber.
		args context stdout
			<< 'Counting, '.
		start to: end  do: [ :each | args context stdout << each asString ; space ]
		]
]]]

What we see is that positionals are read in sequence.

[[[
> clap months 5
Counting months, 5 6 7 8 9 10 11 12
]]]

An important point to consider is that the values that we get from the command line are strings.
This is why we have to convert them to the objects we want.
Here we convert the month index into numbers so that we can iterate between them.

A better way is to use the ==#meaning:== message of a particular positional to specify the conversion.
Here we rewrite the command to show you the effect

[[[
myCounter
	<commandline>
	^ (ClapCommand withName: 'bettermonths')
		add: ((ClapPositional withName: 'from')
				meaning: [ :pos | pos word asNumber ];
				implicitMeaning: [ 1 ]);
		add: ((ClapPositional withName: 'to')
				meaning: [ :pos | pos word asNumber ];
				implicitMeaning: [ 12 ]);
		meaning: [ :args |
			| start end |
			start := (args atName: 'from') value.
			end := (args atName: 'to') value.
			args context stdout
				<< 'Counting, '.
			start to: end  do: [ :each | args context stdout << each asString ; space ]
		]
]]]

But a better way to define the behavior is to follow the pattern presented in Section. 




!!! Multiple times the same positionable

from SD to CDLM: more here
[[[
ClapCommandLineExamples>>recipients
	^ (arguments at: #who) allOccurrencesCollect: [ :arg | arg value: self ]
]]]


[[[
> clap hello foo bar baz
hello, foo.
hello, bar.
hello, baz.
]]]

!!!Parameter matches, meanings, and values

Let's take a short tangent here, since there are a few things to unpack.

First, to use an argument, in this case the greeting's recipient passed via the ==who== positional, we query for it.
A command matches based on just its name, and once it does, it matches its parameters against the rest of the command line.
The command's behavior is specified by its meaning block, where ==args== receives a ''match'' describing what, where, and how the ==hello== command matched the command line.
Like parameters, matches are recursively structured: ==args== contains a child match describing how the ==who== positional matched, which we obtain with the ==#atName:== query message.
As you can see, matches also provide convenience accessors to the command's execution context, for instance the standard output stream.

@@note from SD to CDLM: I found the match above confusing. Similarly the following paragraph is unclear. I did not get what you want to say. I read the text but it does not mean much to me. I do not understand what is a match nor what is a meaning.

Second, the role of the meaning block of a parameter is to translate matches of that parameter into domain values or behavior.
Clap provides a basic meaning for all parameters, which you can override using the ==#meaning:== accessor; to evaluate the meaning of a given match, send it ==#value==.
Most commands will specify a custom meaning because the basic one just returns the match.
However, for positionals, the basic meaning returns the matched command line word, which happens to be exactly what we need for ==who== in this example.

Finally, let's look at what happens if we run ==hello== but omit the positional:
[[[language=shell
> clap hello
hello, world
]]]

In that case, for lack of an explicit match, the query for =='who'== returns an ''implicit match'', which answers ==#value== using the ==#implicitMeaning:== block instead of the basic meaning, thus returning the recipient =='world'==.








!!!Flags and options

from SD to CDLM: more here please
!!!! default boolean value

tu peux toujours faire ==aFlagMatch isExplicit== pour savoir si il était présent explicitement

mais aFlagMatch value fait la même chose si tu ne lui as pas donné de meaning





!!!Exist success

[[[
meaning: [ :args | 
			args exitSuccess
				]
]]]

Usually we do not have to do it since when the block is fully executed an exitSuccess is raised

[[[
meaning: [ :args | 
			args exitFailure
				]
]]]

status one

[[[
meaning: [ :args | 
			args exitFailure:
				]
]]]

status one



!!!Commands and subcommands

Reoops!
How do I write a command then :(

How we access parent command from subcommand 
args context parent probably?

the example is 

[[[
myCommand 
	— baseDirectory
	— months
	— renter

et je veux dump qui fait un dump donc comme sous commande?

	— dump 
]]]


	comment dump peut acceder a —basedirectory


quittance —baseDirectory /tmp -dump 

]]]

!!! Free help 

flag help et command help

!!!! flag help
Create a text based on the command elements (positionables,.... )
[[[
clap hello --help
> 

> clap eval --help 
]]]

Pay attention the flag should be explicitly check in the command meaning
Because \-\-help takes precedence over the other arguments. 

[[[
hello
	"The usual Hello-World example, demonstrating a Clap command with a couple options."

	<commandline>
	^ (ClapCommand withName: 'hello')
		description: 'Provides greetings';
		add: ClapFlag forHelp;
		add: ((ClapFlag withName: 'whisper') description: 'Greet discretely');
		add: ((ClapFlag withName: 'shout') description: 'Greet loudly');
		add:
			((ClapFlag withName: 'language')
				description: 'Select language of greeting';
				add: ((ClapPositional withName: 'langCode')
					meaning: [ :pos | pos word asSymbol ];
					implicitMeaning: [ #en ]);
				meaning: [ :flag | (flag atName: 'langCode') value ]);
		add:
			((ClapPositional withName: 'who')
				description: 'Recipient of the greetings';
				multiple: true;
				implicitMeaning: [ 'world' ]);
		meaning: [ :args | 
			args
				atName: 'help'
				ifFound: [ :help | 
					help
						value;
						exitSuccess ].
			(self with: args) sayHello ]
]]]



!!!! Command help

A command help also exists. It documents either the commands available or let you specify the one you want. 
[[[
pharo80 P8Indian.image clap help      
Entry point for commands implemented with Clap

Usage: clap [--help]

Options:
    --help      Prints this documentation

Commands:
    help        Prints command documentation
    evaluate    Print the result of a Pharo expression
    hello       Provides greetings
    version     Displays version information, in various formats
    bettermonths
]]]

[[[
pharo80 P8Indian.image clap help hello
Provides greetings

Usage: hello [--help] [--whisper] [--shout] [--language] [<who>]

Parameters:
    <who>       Recipient of the greetings

Options:
    --help      Prints this documentation
    --whisper   Greet discretely
    --shout     Greet loudly
    --language
                Select language of greeting
]]]


!!! Command vs. flag

flag: you have to manage it explicitly 
- add flag ==add: ClapFlag forHelp;==
- in meaning: 

[[[
args
	atName: 'help'
	ifFound: [ :help |
		help
			value;
			exitSuccess ].
]]]

command: 
Potential Conflict with positional

[[[
> clap hello help 
Hello, help 
]]]



!! Patterns of command definition

!!! Patterns to express meaning

[[[
meaning: [ :args | 
			args
				atName: 'help'
				ifFound: [ :help | 
					help
						value;
						exitSuccess ].
			(self with: args) sayHello ]
]]]


[[[
with: arguments
	^ self new
		setArguments: arguments;
		yourself
]]]



Control the border between the shell world (strings) and Pharo objects.
Two choices:
- convert in the meaning block from string to objects
- pass all the arguments to the domain with a specific API 



!!Clap Explained

Clap is a framework for adding rich command line interfaces to Pharo code; it sits at the frontier of the image, between application code and the shell environment.
There are two main families of objects in Clap:
- ''Specifications'' describe the syntax and behavior of commands that the image understands.
- ''Activations'' represent command invocations and their arguments, their domain-level meaning, and which words they map to.

Before we start with the details, let's recap the general workflow with Clap:
# On the shell side, the user invokes a command, either directly in the terminal or from a shell script; for convenience, that command would usually be an alias or a small wrapper around the correct Pharo virtual machine and image.
# On the image side, Clap receives the command with its arguments as an array of words, and creates an activation context, matching the arguments with known commands specifications.
# A successful match has meaning defined by application code, which queries the context for domain-level meaning or raw syntax of command parameters, and for external resources like input/output streams.
# When the application code runs to completion, Clap cleanly exits the image. Alternatively, the application can tell the context to terminate early, with a deliberate exit status, or if it fails to handle an exception, Clap catches it and gracefully reports the error.





!!!Specifications

% extending with custom parameter kinds

!!!Activations

+Main specification classes>file://figures/parameters/Specifications.pdf|width=70|label=specificationClasses+
+Main activation classes>file://figures/parameters/Activations.pdf|width=70|label=activationClasses+
+Context and tree of matches>file://figures/parameters/tree.pdf|width=70|label=matchTree+


!!Clap Internals
